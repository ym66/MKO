library BinSearchDLL;

uses
  SysUtils, Classes, Windows;

function SearchInBinaryFileAuto(
  const FileName: PChar;
  const Pattern: Pointer;
  const PatternLen: Integer; // 0 → строка, >0 → байты
  var PositionsStr: PChar
): Boolean; stdcall;
const
  BUF_SIZE = 65536; // 64 KB
var
  FS: TFileStream;
  Buffer: array of Byte;
  ReadBytes, i, Overlap: Integer;
  GlobalOffset: Int64;
  TempStr: string;
  SearchData: TBytes;
  ActualLen: Integer;
begin
  Result := False;
  PositionsStr := nil;
  TempStr := '';

  if (FileName = nil) or (Pattern = nil) then Exit;
  if not FileExists(FileName) then Exit;

  // Определяем длину шаблона
  if PatternLen = 0 then
    ActualLen := StrLen(PAnsiChar(Pattern)) // строка
  else
    ActualLen := PatternLen;               // бинарные данные

  if ActualLen <= 0 then Exit;

  // Записываем шаблон в массив байтов
  SetLength(SearchData, ActualLen);
  Move(Pattern^, SearchData[0], ActualLen);

  FS := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  try
    SetLength(Buffer, BUF_SIZE + ActualLen - 1);
    GlobalOffset := 0;

    while FS.Position < FS.Size do
    begin
      ReadBytes := FS.Read(Buffer[0], BUF_SIZE);

      // Перекрытие на границах
      if (FS.Position < FS.Size) and (ActualLen > 1) then
      begin
        Overlap := ActualLen - 1;
        FS.Read(Buffer[ReadBytes], Overlap);
        FS.Position := FS.Position - Overlap;
        Inc(ReadBytes, Overlap);
      end;

      for i := 0 to ReadBytes - ActualLen do
      begin
        if CompareMem(@Buffer[i], @SearchData[0], ActualLen) then
        begin
          if TempStr <> '' then TempStr := TempStr + ',';
          TempStr := TempStr + IntToStr(GlobalOffset + i);
        end;
      end;

      Inc(GlobalOffset, ReadBytes - (ActualLen - 1));
    end;

    if TempStr <> '' then
    begin
      PositionsStr := StrAlloc(Length(TempStr) + 1);
      StrPCopy(PositionsStr, TempStr);
    end;

    Result := True;
  finally
    FS.Free;
  end;
end;

exports
  SearchInBinaryFileAuto;

begin
end.

Для строк:
type
  TSearchInBinaryFileAuto = function(
    const FileName: PChar;
    const Pattern: Pointer;
    const PatternLen: Integer; // 0 = строка
    var PositionsStr: PChar
  ): Boolean; stdcall;

var
  DLLHandle: THandle;
  SearchFunc: TSearchInBinaryFileAuto;
  PosStr: PChar;
begin
  DLLHandle := LoadLibrary('BinSearchDLL.dll');
  if DLLHandle <> 0 then
  try
    @SearchFunc := GetProcAddress(DLLHandle, 'SearchInBinaryFileAuto');
    if Assigned(SearchFunc) then
    begin
      if SearchFunc('test.bin', PAnsiChar('Hello'), 0, PosStr) then
      begin
        if PosStr <> nil then
        begin
          Writeln('Найдено: ', PosStr);
          StrDispose(PosStr);
        end
        else
          Writeln('Совпадений нет');
      end;
    end;
  finally
    FreeLibrary(DLLHandle);
  end;
end;

Для байтов:
var
  Pattern: array[0..2] of Byte = ($DE, $AD, $BE);
begin
  if SearchFunc('test.bin', @Pattern[0], Length(Pattern), PosStr) then
  begin
    Writeln('Найдено: ', PosStr);
    StrDispose(PosStr);
  end;
end;
