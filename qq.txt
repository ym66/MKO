function FindSubstringInFile(FileName: PChar; SubStr: PByte; SubStrLen: Integer): PChar; stdcall;
const
  BUFFER_SIZE = 65536; // 64 КБ
var
  Stream: TFileStream;
  Buffer: array of Byte;
  BytesRead, I: Integer;
  Found: Boolean;
  Positions: TStringList;
  ResultStr: string;
  SearchPos: Int64;
begin
  Result := nil;
  Positions := TStringList.Create;
  try
    try
      // Проверка входных параметров
      if (SubStrLen <= 0) or (SubStr = nil) or (FileName = nil) then
      begin
        Result := StrAlloc(1);
        Result[0] := #0;
        Exit;
      end;

      // Открываем файл
      Stream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyNone);
      try
        SetLength(Buffer, BUFFER_SIZE + SubStrLen - 1);
        SearchPos := 0;

        // Первоначальное чтение
        BytesRead := Stream.Read(Buffer[0], BUFFER_SIZE);
        if BytesRead < SubStrLen then
        begin
          // Файл слишком маленький
          Result := StrAlloc(10);
          StrPCopy(Result, 'Not found');
          Exit;
        end;

        while BytesRead >= SubStrLen do
        begin
          // Поиск в текущем буфере
          for I := 0 to BytesRead - SubStrLen do
          begin
            Found := True;
            for var J := 0 to SubStrLen - 1 do
              if Buffer[I + J] <> SubStr[J] then
              begin
                Found := False;
                Break;
              end;

            if Found then
              Positions.Add(IntToStr(SearchPos + I));
          end;

          // Сохраняем конец буфера для перекрытия
          if BytesRead >= SubStrLen - 1 then
          begin
            Move(Buffer[BytesRead - (SubStrLen - 1)], Buffer[0], SubStrLen - 1);
            SearchPos := SearchPos + BytesRead - (SubStrLen - 1);
          end;

          // Читаем следующую порцию
          BytesRead := Stream.Read(Buffer[SubStrLen - 1], BUFFER_SIZE);
          if BytesRead > 0 then
            BytesRead := BytesRead + (SubStrLen - 1);
        end;

        // Формируем результат
        if Positions.Count > 0 then
          ResultStr := Positions.CommaText
        else
          ResultStr := 'Not found';

        Result := StrAlloc(Length(ResultStr) + 1);
        StrPCopy(Result, ResultStr);
      finally
        Stream.Free;
      end;
    except
      on E: Exception do
      begin
        Result := StrAlloc(64);
        StrPCopy(Result, 'Error: ' + E.Message);
      end;
    end;
  finally
    Positions.Free;
  end;
end;